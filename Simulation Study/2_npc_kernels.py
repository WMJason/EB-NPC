import networkx as nx
import math
import json
import ast # For safely loading nodes from GraphML/strings and knots from CSV
import pandas as pd
from typing import List, Tuple, Optional, Dict, Any

# --- Core NPC Functions (Unchanged) ---

def get_network_distance(site: Any, knot: Any, G: nx.Graph) -> float:
    """
    Computes network distance (hop count) between site (origin) and knot 
    (destination) in the original (unsubdivided) graph.
    """
    try:
        # Distance is equal to the unweighted shortest path length (hop count)
        distance = nx.shortest_path_length(G, source=site, target=knot)
        return float(distance)
    except nx.NetworkXNoPath:
        return float('inf')


def epanechnikov_kernel(d: float, h: float) -> float:
    """Epanechnikov kernel (compact support): returns 0 if d>h."""
    if d > h:
        return 0.0
    # Kernel formula: K(d) = 0.75 * (1 - (d/h)^2)
    return 0.75 * (1.0 - (d / h) ** 2)


def compute_reweight_factor(site: Any, knot: Any, G: nx.Graph, path_nodes: Optional[List[Any]] = None) -> float:
    """
    Computes the reweighting factor w_(s,u) using the original network.
    """
    
    # 1. Get path nodes if not provided
    if path_nodes is None:
        try:
            path_nodes = nx.shortest_path(G, source=site, target=knot)
        except nx.NetworkXNoPath:
            return 0.0

    # 2. Intermediate nodes: exclude endpoints of the path
    inter_nodes = path_nodes[1:-1]

    # 3. Product over (deg(v) - 1) for intermediate intersections
    prod = 1.0
    for v in inter_nodes:
        deg_v = G.degree(v)
        # Only nodes with deg >= 3 are considered "intersections" in the path structure
        if deg_v >= 3:
             # Ensure the factor is at least 1 to avoid division by zero/erroneous growth
            prod *= max(1, (deg_v - 1)) 
        # For a straight road segment node (deg=2), factor is 1, so no change to prod.

    prod = max(prod, 1.0) # Ensure prod is at least 1.0 if no intermediate intersections
    
    # 4. Apply the initial factor based on the origin (site)
    deg_site = G.degree(site)
    
    # Since all nodes are intersections (s in V): w = (2 / deg(s)) * (1 / prod)
    w = (2.0 / float(deg_site)) * (1.0 / prod)

    return float(w)


def _get_intersections_on_path(G: nx.Graph, path_nodes: List[Any]) -> int:
    """Counts nodes with degree >= 3 (intersections) along the path, excluding endpoints."""
    count = 0
    # Intermediate nodes only (path_nodes[1:-1])
    for v in path_nodes[1:-1]:
        if G.degree(v) >= 3:
            count += 1
    return count

# --- NEW FUNCTION: Load Knots ---

def load_knots(filename: str) -> List[Any]:
    """
    Loads knot IDs from the CSV file generated by network_builder.py.
    The IDs must be converted from string representation back to tuples.
    """
    try:
        df_knots = pd.read_csv(filename)
        # Convert the string representation of the tuple back to a tuple object
        knots = [ast.literal_eval(node_str) for node_str in df_knots['node_id']]
        print(f"Loaded {len(knots)} knot IDs from {filename}.")
        return knots
    except FileNotFoundError:
        print(f"❌ ERROR: Knot file not found: {filename}")
        return []
    except Exception as e:
        print(f"❌ ERROR loading knots: {e}")
        return []


# --- Modified Main Export Function ---

def generate_node_to_knot_path_data(G: nx.Graph, knots: List[Any], h: float, filename: str = "node_path_data.json"):
    """
    Computes and exports the required shortest path data for all Node-to-Knot pairs (s -> u),
    including kernel and reweighted kernel values (K*(s,u)).
    """
    
    sites = list(G.nodes())
    print(f"Starting path pre-calculation for {len(sites)} sites (all nodes) and {len(knots)} knots with bandwidth h={h}...")
    
    all_path_data: Dict[str, Dict[str, Dict[str, Any]]] = {}
    
    # Pre-calculate all-pairs shortest paths using unweighted BFS
    # We must calculate paths from ALL sites to ALL knots
    try:
        all_shortest_paths_gen = nx.shortest_path(G)
    except nx.NetworkXNoPath:
        print("Error: The graph is disconnected. Cannot compute all-pairs shortest paths.")
        return

    for site in sites:
        site_id = str(site)
        all_path_data[site_id] = {}
        
        paths_from_site = all_shortest_paths_gen.get(site, {})
        
        for knot in knots: # Iterate only over the selected KNOTS
            knot_id = str(knot)
            
            if knot == site:
                # Self-influence values
                kernel_0 = epanechnikov_kernel(0.0, h)
                all_path_data[site_id][knot_id] = {
                    "distance": 0.0,
                    "reweight_factor": 1.0, 
                    "kernel_value": kernel_0,
                    "reweighted_kernel_value": kernel_0 * 1.0,
                    "num_intersections": 0,
                    #"path": [site_id]
                }
                continue

            path_nodes = paths_from_site.get(knot)
            
            if path_nodes:
                # Calculations
                distance = get_network_distance(site, knot, G)
                reweight_factor = compute_reweight_factor(site, knot, G, path_nodes)
                kernel_value = epanechnikov_kernel(distance, h)
                reweighted_kernel_value = kernel_value * reweight_factor
                num_intersections = _get_intersections_on_path(G, path_nodes)
                
                all_path_data[site_id][knot_id] = {
                    "distance": distance,
                    "reweight_factor": reweight_factor,
                    "kernel_value": kernel_value,
                    "reweighted_kernel_value": reweighted_kernel_value,
                    "num_intersections": num_intersections,
                    #"path": [str(n) for n in path_nodes] 
                }
            
            else:
                # No path exists
                all_path_data[site_id][knot_id] = {
                    "distance": float('inf'),
                    "reweight_factor": 0.0,
                    "kernel_value": 0.0,
                    "reweighted_kernel_value": 0.0,
                    "num_intersections": 0,
                    #"path": []
                }
                
    # 5. Export to JSON
    with open(filename, 'w') as f:
        def convert_to_serializable(obj):
            if obj == float('inf'):
                return "inf"
            return obj
            
        json.dump(all_path_data, f, indent=4, default=convert_to_serializable)
        
    print(f"✅ Exported Node-to-Knot path and kernel data to {filename}")
    return all_path_data


if __name__ == "__main__":
    # --- Example Usage (requires networkx, pandas, and outputs from network_builder.py) ---
    
    H_BANDWIDTH = 12
    
    # Helper to load the graph
    def load_graphml_with_tuple_nodes(filename):
        H = nx.read_graphml(filename)
        G = nx.Graph()
        
        # Convert nodes from string '(r, c)' back to tuple (r, c)
        node_map = {}
        for node_str in H.nodes:
            try:
                node_tuple = ast.literal_eval(node_str)
                node_map[node_str] = node_tuple
                G.add_node(node_tuple)
            except:
                continue

        for u_str, v_str, data in H.edges(data=True):
            # Lookup the converted node objects
            u_tuple = node_map.get(u_str)
            v_tuple = node_map.get(v_str)

            if u_tuple and v_tuple:
                # Convert attributes read as strings back to their types
                data['AADT'] = int(data.get('AADT', 0))
                data['length'] = float(data.get('length', 1.0))
                
                G.add_edge(u_tuple, v_tuple, **data)
                
        return G
    
    try:
        # 1. Load the Graph and Knots
        G = load_graphml_with_tuple_nodes('1_network.graphml')
        knots_list = load_knots('1_knots.csv')

        # 2. Run the Node-to-Knot calculation
        generate_node_to_knot_path_data(
            G, 
            knots=knots_list, 
            h=H_BANDWIDTH, 
            filename="2_sp_info_nodes.json" # Renamed output for sequential clarity
        )
    except FileNotFoundError:
        print("\n⚠️ WARNING: Missing required input files ('1_network.graphml' or '1_knots.csv'). Cannot run live test.")
        print("Please ensure you run the `network_builder.py` script first.")
    except Exception as e:
        print(f"\n⚠️ WARNING: Error during graph loading/processing: {e}")
